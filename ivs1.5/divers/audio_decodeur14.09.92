
/**************************************************************************\
*          Copyright (c) 1992 INRIA Sophia Antipolis, FRANCE.              *
*                                                                          *
* Permission to use, copy, modify, and distribute this material for any    *
* purpose and without fee is hereby granted, provided that the above       *
* copyright notice and this permission notice appear in all copies.        *
* WE MAKE NO REPRESENTATIONS ABOUT THE ACCURACY OR SUITABILITY OF THIS     *
* MATERIAL FOR ANY PURPOSE.  IT IS PROVIDED "AS IS", WITHOUT ANY EXPRESS   *
* OR IMPLIED WARRANTIES.                                                   *
\**************************************************************************/
/**************************************************************************\
*                                                                          *
*  File    : audio_decoder.c                                               *
*  Date    : September 1992                                                *
*  Author  : Thierry Turletti                                              *
*--------------------------------------------------------------------------*
*  Description :  Audio decoder.                                           *
*                                                                          *
\**************************************************************************/

#include <stdio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <fcntl.h>
#ifdef DECSTATION
#include <Alib.h>
#endif 
#include "protocol.h"


#define maxi(x,y) ((x)>(y) ? (x) : (y))
 

#ifdef DECSTATION

Bool check(event)
     aEvent *event;
{
  if(event->u.u.type == N_SoundPosition)
    printf("received a N_SoundPosition event\n");
  else{
    if(event->u.u.type == N_CommandStart)
      printf("received a N_CommandStart event\n");
    else
      printf("received an event type %d\n", event->u.u.type);
  }
}

#endif /* DECSTATION */


void Audio_Decode(fd, port, group)
     int fd[2];
     char *port, *group;
{
  struct sockaddr_in addr, from;
  int len_addr, fromlen, outlen;
  int sock;
  int mask_pipe, mask_sock, mask, smask, mask0, fmax;
  unsigned char buf[P_MAX], outbuf[P_MAX], *pt_out;
  int lr, n;
  char header;
  int type;
  struct timeval tim;
  LOCAL_TABLE table;
#ifdef DECSTATION
  AudioServer       *aserver = NULL;
  LoudId             rootloudid;
  LoudId	     cloud;
  AEventMask	     Mask;	    
  VDeviceId          player;
  SoundId            soundid;
  SoundOp            soundop;
  aSoundType         soundtype;
  aLoudAttributes    cloudAttrs;
  aSoundHandleAttributes soundAttrs;
  SoundValueMask     soundValueMask;
  int                length=125; /* duration : 125 ms --> 1000 bytes*/
  aEvent event;
#endif /* DECSTATION */

  /*
  *  Initializations
  */
  InitTable(table);
  sock = CreateReceiveSocket(&addr, &len_addr, port, group);
  tim.tv_sec = 0;
  tim.tv_usec = 0;
  mask_pipe = 1 << fd[0];
  mask_sock = 1 << sock;
  mask0 = mask_pipe | mask_sock;
  fmax = maxi(fd[0], sock) + 1;
  fromlen = sizeof(from);


#ifdef SPARCSTATION
  if(!soundinit(O_WRONLY)) {
    fprintf(stderr, "audio_decode: Cannot open audio device.\n");
    exit(-1);
  }
#elif DECSTATION

  /* initialize audio connection  */
  aserver = AOpenAudio(NULL);
  if(aserver == NULL){
    fprintf(stderr, "audio_decode: Cannot open audio device.\n");
    exit(-3);
  }
  rootloudid = AGetRootLoudId(aserver);

  /* create the cloud */
  Mask = LoudEventMaskValue;
  cloudAttrs.eventmask = QueueNotifyMask /*| DeviceNotifyMask*/;
  cloud = ACreateLoud(aserver, rootloudid, Mask, &cloudAttrs, ACurrentTime);

  /* enable synchronization */
/*  ASynchronize(aserver, 1);*/

  /* create the player as a child of 'cloud' */
  player = CreatePlayer(aserver, cloud);

  /* map and activate the cloud */
  AMapLoud(aserver, cloud, ACurrentTime);

  /* Create a Sound Handle */
  soundValueMask =
    SoundModeValue | SoundLengthValue | SoundTypeValue;

  soundAttrs.soundmode = soundHandleLoopBuffer | soundHandleRead |
                      soundHandleWrite;
  soundAttrs.length = 1024;
  soundAttrs.soundtype.sampleRate = 8000;
  soundAttrs.soundtype.sampleSize = 8;
  soundAttrs.soundtype.encoding = AA_8_BIT_ULAW;
  soundid =
    ACreateSoundHandle(aserver, soundValueMask, &soundAttrs, ACurrentTime);
 
#endif /* DECSTATION */
  do{
    mask = mask0;
    smask = mask_sock;
    if(select(fmax, (fd_set *)&mask, (fd_set *)0, (fd_set *)0, 
		  (struct timeval *)0) > 0){

      if((n=select(sock+1, (fd_set *)&smask, (fd_set *)0, (fd_set *)0, 
		  (struct timeval *)&tim)) > 0){ 
	do{
	  bzero((char *)&from, fromlen);
	  if((lr=recvfrom(sock, (char *)buf, P_MAX, 0, &from, &fromlen)) < 0){
	    perror("audio_decode (recvfrom) :");
	  }
	  if((type=GetType(buf)) != AUDIO_TYPE){
	    fprintf(stderr, 
		    "audio_decode: received and dropped a packet type %d\n", 
		    type);
	  }else{
	    if(ShallIDecode(table, from.sin_addr.S_un.S_addr)){
	      switch(buf[1]){
	      case PCM_64:
		pt_out = &buf[2];
		outlen = lr-2;
		break;
	      case ADPCM_32:
		outlen = (lr-2)*2;
		adpcm_decoder(&buf[2], outbuf, outlen);
		pt_out = outbuf;
		break;
	      case VADPCM:
		outlen = vadpcm_decoder(&buf[2], outbuf, lr-2);
		pt_out = outbuf;
		break;
	      }
#ifdef SPARCSTATION
	      soundplay(outlen, pt_out);
#elif DECSTATION
	      printf("before APutSoundData: received %d bytes\n", outlen);
	      APutSoundData(aserver, soundid, soundop, 0, soundAttrs.soundtype,
			    outlen, (SoundData) pt_out, ACurrentTime);
	      AFlush(aserver);
	      printf("after APutSoundData\n");
	      APlay(aserver, cloud, player, soundid, 0, End, ACurrentTime);
	      printf("after APlay\n");
	      AFlush(aserver);
	      /* wait until the Play command has completed before exiting */
	      ANextEvent(aserver, &event);
	      while(event.u.u.type != N_CommandDone){
		if(event.u.u.type == N_SoundPosition)
		  printf("received a N_SoundPosition, value: %d\n", 
			 event.u.soundPositionN.position);
		else{
		  if(event.u.u.type == N_CommandStart)
		    printf("received a N_CommandStart\n");
		  else
		    printf("received a %d type event\n", event.u.u.type);
		}
		ANextEvent(aserver, &event);
	      }
#endif
	    }
	  }
	}while(--n);
      }
      if(mask & mask_pipe){
	if((lr = read(fd[0], &header, 1)) != 1){
	  fprintf(stderr, 
		  "audio_decode: Cannot read on pipe, Abort decoding\n");
	  exit(1);
	}else{
	  switch((int)(header)){
	    case PP_QUIT:
#ifdef SPARCSTATION
	      soundterm();
#elif DECSTATION
	      AStop(aserver, cloud, player, ImmediateRequest, ACurrentTime);
	      ADeleteSoundHandle(aserver, soundid, ACurrentTime);
	      AFlush(aserver);
	      ACloseAudio(aserver);
#endif
	      exit(0);
	    case PP_NEW_TABLE:
	      if ((lr=read(fd[0], table, sizeof(table))) < 0) {
		fprintf(stderr, 
			"audio_decode : Cannot read on pipe, Abort decoding");
	      }else{
#ifdef DEBUG
		printf("audio_decode: received new audio table %d bytes\n", 
		       lr);
#endif          ;
	      }
	      break;
	    default:
	      fprintf(stderr, 
		 "audio_decode: received on pipe an unknown packet type %d\n",
		      (u_long)buf[0]);
          }
	}
      }
    }
  }while(1);
}










    

